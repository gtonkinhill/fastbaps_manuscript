---
title: "Supplementary Material - Simulations"
author: "Gerry Tonkin-Hill"
date: "`r Sys.Date()`"
output: 
  html_document:
    fig_width: 12
    fig_height: 8
editor_options: 
  chunk_output_type: console
---

```{r global_options, include=FALSE}
knitr::opts_chunk$set(fig.width=20, fig.height=12,
                      echo=TRUE, warning=FALSE, message=FALSE,
                      tidy=TRUE)
options(stringsAsFactors = FALSE)
```

## Libraries

```{r}
library(readr)
library(fastbaps)
library(coala)
library(Matrix)
library(clusteval)
library(adegenet)
library(parallel)
library(dbscan)
library(ape)
library(data.table)
library(ggplot2)
library(rhierbaps)
library(starmie)

STRUCTURE_BINARY <- "/home/gerryt/software/structure/structure"
CPU <- 15
```

Simulators available

```{r}
# activate_msms(download = TRUE)
# activate_seqgen("/Users/gt4/software/Seq-Gen.v1.3.3/source/seq-gen")
activate_scrm(priority = 600)
list_simulators()
```

Helper functions

```{r}
make_AG <- function(sum.stats, pop.sizes, prop.sample){
  pops <- rep(1:length(pop.sizes), pop.sizes)
  x <- sum.stats$segsites[[1]]$snps
  
  keep <- sample(1:nrow(x), ceiling(nrow(x)*prop.sample))
  
  pops <- pops[keep]
  x <- x[keep, ]
  
  aln <- matrix("", nrow = nrow(x), ncol = ncol(x))
  aln[x==1] <- 'A'
  aln[x!=1] <- 'G'
  aln <- ape::as.DNAbin(aln)
  rownames(aln) <- paste(paste("seq", 1:nrow(x), sep=""), paste("pop", pops, sep=""), sep = "_")
  return(list(aln=aln, pops=pops))
}

distance <- function(p, start.point, end.point){
  x1 <- start.point[[1]]
  y1 <- start.point[[2]]
  x2 <- end.point[[1]]
  y2 <- end.point[[2]]
  x0 <- p[[1]]
  y0 <- p[[2]]
  
  d <- abs((y2-y1)*x0 - (x2-x1)*y0 + x2*y1 - y2*x1)/sqrt((y2-y1)^2 + (x2-x1)^2)
  
  return(d)
}


elbow <- function(sizes){
  n <- length(sizes)
  x <- 1:n
  start.point <- c(1, sizes[[1]])
  end.point <- c(n, sizes[[n]])
  
  return(unlist(lapply(1:n, function(i) distance(c(i, sizes[[i]]), start.point, end.point))))
  
}

fowlkes_mallows <- function(clust.A, clust.B){
  tab <- clusteval::comembership_table(clust.A, clust.B)
  return(tab$n_11/sqrt((as.numeric(tab$n_11+tab$n_10))*as.numeric((tab$n_11+tab$n_01))))
}

simulate_island_inputs <- function(n.pops, pop.size, seq.length,
                            mutation.rate, recombination.rate, migration.rate,
                            sample.proportion, sim.id, directory)
  {
  
  population.sizes <- rep(pop.size, n.pops)
  
  # model <- coala::coal_model(sample_size = population.sizes, loci_number = 1, loci_length = seq.length) +
  #   feat_mutation(mutation.rate) +
  #   feat_recombination(recombination.rate) +
  #   feat_migration(rate = migration.rate, symmetric = TRUE) +
  #   sumstat_seg_sites("segsites")
  # 
  # simu.stats <- simulate(model)
  # 
  # simu <- make_AG(simu.stats, population.sizes, sample.proportion)
  
  fasta.file.name <- paste(c(directory, "/simulation_", sim.id, ".fasta"), collapse = "")
  
  # ape::write.FASTA(simu$aln, file = fasta.file.name)
  
  sparse.data <- fastbaps::import_fasta_sparse_nt(fasta.file.name)
  
  # simu.gene.id <- DNAbin2genind(simu$aln)
  fasta <- ape::read.FASTA(fasta.file.name)
  simu <- list(pops=as.numeric(gsub(".*_pop", "", names(fasta))))
  simu.gene.id <- DNAbin2genind(fasta)
  
  return(list(simu.clusters=simu$pops,
         simu.gene.id=simu.gene.id,
         simu.sparse.data=sparse.data,
         fasta.file.name=fasta.file.name,
         structure.file.name=NULL
         ))

}

calc_clusters_fastbaps <- function(sparse.data){
  
  sparse.data <- optimise_prior(sparse.data, type = "baps")
  baps.prior <- fastbaps::fast_baps(sparse.data, quiet = TRUE)
  baps.prior <- fastbaps::best_baps_partition(sparse.data, baps.prior, quiet = TRUE)
  
  sparse.data <- optimise_prior(sparse.data, type = "optimise.baps")
  opt.baps.prior <- fastbaps::fast_baps(sparse.data, quiet = TRUE)
  opt.baps.prior <- fastbaps::best_baps_partition(sparse.data, opt.baps.prior, quiet = TRUE)
  
  sparse.data <- optimise_prior(sparse.data, type = "symmetric")
  opt.symmetrix.prior <- fastbaps::fast_baps(sparse.data, quiet = TRUE)
  opt.symmetrix.prior <- fastbaps::best_baps_partition(sparse.data, opt.symmetrix.prior, quiet = TRUE)

  return(list(fb.baps.prior=baps.prior,
         fb.opt.baps.prior=opt.baps.prior,
         fb.opt.symmetric.prior=opt.symmetrix.prior))

}

calc_cluster_snapclust <- function(gene.id, max.k=25){
  snap.clust <- mclapply(2:max.k, function(k) adegenet::snapclust(gene.id, k), mc.cores = 1)
  snap.clust.aic <- unlist(lapply(snap.clust, adegenet::AIC.snapclust))
  snap.clust.bic <- unlist(lapply(snap.clust, adegenet::BIC.snapclust))
  
  snap.best.k.aic <- snap.clust[[which.min(snap.clust.aic)]]
  snap.best.k.aic <- as.numeric(snap.best.k.aic$group)
  
  snap.best.k.bic <- snap.clust[[which.min(snap.clust.bic)]]
  snap.best.k.bic <- as.numeric(snap.best.k.bic$group)
  
  return(list(snap.best.k.aic=snap.best.k.aic,
              snap.best.k.bic=snap.best.k.bic))
}

calc_cluster_hierbaps <- function(gene.id){
  hb.results <- rhierbaps::hierBAPS(as.matrix(genind2df(gene.id)), max.depth = 1, n.pops = 50, quiet = TRUE)
  return(list(hierbaps=hb.results$partition.df$`level 1`))
}

run_structure_adapt <- function (path_to_structure, input_file, main_params, extra_params, 
    out_prefix, n_K, n_replicates, n_loci, n_inds, n_cores) 
{
    stopifnot(file.exists(path_to_structure))
    stopifnot(file.exists(input_file))
    stopifnot(file.exists(main_params))
    stopifnot(file.exists(extra_params))
    if (!is.integer(n_K) & n_K < 1) {
        stop("Assumed populations must be greater than 1")
    }
    if (!is.integer(n_replicates) & n_replicates < 1) {
        stop("Number of replicates must be greater than 1")
    }
    if (n_cores > parallel::detectCores()) {
        stop("Number of cores greater than available on machine.")
    }
    K <- c(n_K)
    replicates <- 1L:n_replicates
    out_files <- outer(replicates, K, function(x, y) paste0(out_prefix, 
        stringr::str_pad(x, width = 2, pad = 0), "_K_", stringr::str_pad(y, 
            width = 2, pad = 0), ".out"))
    log_files <- gsub("out", "log", out_files)
    run_structure_single <- function(out_file, log_file) {
        k <- as.integer(stringr::str_extract(out_file, "[0-9]{2}\\b"))
        seed <- round(runif(1) * 1e+08)
        cmd <- paste(path_to_structure, "-K", k, "-i", input_file,
                     "-L", n_loci, "-N", n_inds,
                     "-m", main_params, "-e", extra_params, "-D", seed, 
                     "-o", out_file, "&>", log_file)
        system(cmd)
        return(cmd)
    }
    message(paste("Running STRUCTURE on", n_cores, "core with", 
        n_K, "populations with", n_replicates, "replicates."))
    cmds_run <- parallel::mcmapply(run_structure_single, out_files, 
        log_files, mc.cores = n_cores, mc.set.seed = TRUE)
    message(paste("Commands run\n", paste(cmds_run, collapse = "\n")))
}

write_struct_input <- function(sparse.data, out.file.name){
  alleles <- as.matrix(t(sparse.data$snp.matrix))
  for(j in 1:ncol(alleles)){
    alleles[alleles[,j]==0,j] <- sparse.data$consensus[j]+1
  }
  rownames(alleles) <- gsub("_pop.*", "",
                            gsub("seq", "", colnames(sparse.data$snp.matrix)))
  
  write.table(alleles, file = out.file.name,
              row.names = TRUE, col.names = FALSE, sep=" ", quote = FALSE)
   
}

calc_cluster_structure <- function(sparse.data, prefix, directory, K){
  
  out.prefix <- paste(c(directory, prefix, "_structure_"), collapse="")
  
  out.file.name <- paste(out.prefix, "struct_input.str", sep="_")
  write_struct_input(sparse.data, out.file.name)

  # run_structure_adapt(path_to_structure = STRUCTURE_BINARY,
  #             input_file = out.file.name,
  #             out_prefix = out.prefix,
  #             main_params = "./simulations/island/structure/mainparams",
  #             extra_params = "./simulations/island/structure/extraparams",
  #             n_K =  K, n_replicates = 1, n_loci = nrow(sparse.data$snp.matrix),
  #             n_inds = ncol(sparse.data$snp.matrix), n_cores = 1)
  
  out.files <- Sys.glob(paste(out.prefix, "*.out_f", sep=""))
  log.files <- Sys.glob(paste(out.prefix, "*.log", sep=""))
  
  struct.results <- starmie::structList(mapply(starmie::loadStructure, out.files, log.files, SIMPLIFY = FALSE))
  
  # evanno.results <- starmie::bestK(struct.results, method="structure")
  # evanno.results <- evanno.results[evanno.results$variable == 'AIC',]
  # best.K <- evanno.results$K[which.min(evanno.results$value)]
  # struct.best.K <- struct.results[unlist(lapply(struct.results, getK))==best.K]
  
  struct.best.K <- struct.results[which.max(unlist(lapply(struct.results, function(x) {
    r <- starmie::getFitStats(x)
    return(r[[1]])
  })))][[1]]
  
  cluster <- apply(data.matrix(
    struct.best.K$ancest_df[,3:ncol(struct.best.K$ancest_df)]), 1,
    function(r){
      c(1:struct.best.K$K)[which.max(r)]
    })
  
  return(cluster)
}



```

# Island model

To compare with structure we keep the mutation rate low to ensure the resulting alignment is not too large.

```{r}
n.replicates <- 3

n.pops <- c(5,10, 15, 20, 25)
pop.size <- 1000
seq.length <- 1e5

mutation.rates <- c(0.001, 0.01)
recombination.rates <- c(0, 1, 10)
migration.rates <- c(0.001, 0.01, 0.1, 1)

sample.proportion <- 0.05

parameters.df <- expand.grid(n.pops, mutation.rates, recombination.rates, migration.rates)
parameters.df <- do.call(rbind, lapply(1:n.replicates, function(r){
  cbind(rep(r, nrow(parameters.df)), parameters.df)
}))
colnames(parameters.df) <- c("replicate", "n.pop", "mutation.rate", "recombination.rate", "migration.rate")
dim(parameters.df)

results.df <- do.call(rbind, mclapply(1:nrow(parameters.df), function(i){
  print(i)
  params <- parameters.df[i,,drop=FALSE]
  id <-  paste(paste(colnames(params), params[1,], sep = ""), collapse = "_")
  temp.simulation <- simulate_island_inputs(params$n.pop, pop.size, seq.length,
                                            params$mutation.rate, params$recombination.rate, params$migration.rate,
                                            sample.proportion, 
                                            sim.id = id, 
                                            directory = "./simulations/island/")
  #fastbaps
  fastbaps.results <- calc_clusters_fastbaps(temp.simulation$simu.sparse.data)
  fastbaps.results.df <- do.call(rbind, lapply(1:length(fastbaps.results), function(clust){
    return(data.frame(method=names(fastbaps.results)[[clust]],
                      clusteval::comembership_table(fastbaps.results[[clust]], temp.simulation$simu.clusters),
               fowlkes.mallows = fowlkes_mallows(fastbaps.results[[clust]], temp.simulation$simu.clusters)))
    
  }))
  
  #snapclust
  snapclust.results <- calc_cluster_snapclust(temp.simulation$simu.gene.id)
  snapclust.results.df <- do.call(rbind, lapply(1:length(snapclust.results), function(clust){
    return(data.frame(method=names(snapclust.results)[[clust]],
                      clusteval::comembership_table(snapclust.results[[clust]], temp.simulation$simu.clusters),
               fowlkes.mallows = fowlkes_mallows(snapclust.results[[clust]], temp.simulation$simu.clusters)))
    
  }))
  
  #hierBAPs
  rhierbaps.results <- calc_cluster_hierbaps(temp.simulation$simu.gene.id)
  rhierbaps.results.df <- do.call(rbind, lapply(1:length(rhierbaps.results), function(clust){
    return(data.frame(method=names(rhierbaps.results)[[clust]],
                      clusteval::comembership_table(rhierbaps.results[[clust]], temp.simulation$simu.clusters),
               fowlkes.mallows = fowlkes_mallows(rhierbaps.results[[clust]], temp.simulation$simu.clusters)))
    
  }))
  
  #structure
  structure.results <- calc_cluster_structure(temp.simulation$simu.sparse.data,
                                              prefix = id,
                                              directory = "./simulations/island/structure/",
                                              params$n.pop)
  structure.results.df <- data.frame(method="structure",
                                     clusteval::comembership_table(structure.results, temp.simulation$simu.clusters),
                                     fowlkes.mallows = fowlkes_mallows(structure.results, temp.simulation$simu.clusters))
  
  temp.results.df <- rbind(fastbaps.results.df,
                           snapclust.results.df,
                           rhierbaps.results.df,
                           structure.results.df)
  temp.results.df<- cbind(do.call(rbind, rep(list(params), nrow(temp.results.df))),
                          temp.results.df)
  
  return(temp.results.df)
  
},  mc.cores = CPU))

write.table(results.df, file="./simulations/simulation_results_island.csv",
            row.names = FALSE, col.names = TRUE, quote=FALSE, sep=",")
```


To compare with structure we keep the mutation rate low to ensure the resulting alignment is not too large.

```{r}
n.replicates <- 3

n.pops <- c(5,10, 15, 20, 25)
pop.size <- 1000
seq.length <- 1e5

mutation.rates <- c(0.1, 1)
recombination.rates <- c(0, 1, 10)
migration.rates <- c(0.001, 0.01, 0.1, 1)

sample.proportion <- 0.05

parameters.df <- expand.grid(n.pops, mutation.rates, recombination.rates, migration.rates)
parameters.df <- do.call(rbind, lapply(1:n.replicates, function(r){
  cbind(rep(r, nrow(parameters.df)), parameters.df)
}))
colnames(parameters.df) <- c("replicate", "n.pop", "mutation.rate", "recombination.rate", "migration.rate")
dim(parameters.df)

results.df <- do.call(rbind, mclapply(1:nrow(parameters.df), function(i){
  print(i)
  params <- parameters.df[i,,drop=FALSE]
  id <-  paste("large_mu", paste(paste(colnames(params), params[1,], sep = ""), collapse = "_"), sep="_")
  temp.simulation <- simulate_island_inputs(params$n.pop, pop.size, seq.length,
                                            params$mutation.rate, params$recombination.rate, params$migration.rate,
                                            sample.proportion, 
                                            sim.id = id, 
                                            directory = "./simulations/island/")
  #fastbaps
  fastbaps.results <- calc_clusters_fastbaps(temp.simulation$simu.sparse.data)
  fastbaps.results.df <- do.call(rbind, lapply(1:length(fastbaps.results), function(clust){
    return(data.frame(method=names(fastbaps.results)[[clust]],
                      clusteval::comembership_table(fastbaps.results[[clust]], temp.simulation$simu.clusters),
               fowlkes.mallows = fowlkes_mallows(fastbaps.results[[clust]], temp.simulation$simu.clusters)))
    
  }))
  
  #snapclust
  snapclust.results <- calc_cluster_snapclust(temp.simulation$simu.gene.id)
  snapclust.results.df <- do.call(rbind, lapply(1:length(snapclust.results), function(clust){
    return(data.frame(method=names(snapclust.results)[[clust]],
                      clusteval::comembership_table(snapclust.results[[clust]], temp.simulation$simu.clusters),
               fowlkes.mallows = fowlkes_mallows(snapclust.results[[clust]], temp.simulation$simu.clusters)))
    
  }))
  
  #hierBAPs
  rhierbaps.results <- calc_cluster_hierbaps(temp.simulation$simu.gene.id)
  rhierbaps.results.df <- do.call(rbind, lapply(1:length(rhierbaps.results), function(clust){
    return(data.frame(method=names(rhierbaps.results)[[clust]],
                      clusteval::comembership_table(rhierbaps.results[[clust]], temp.simulation$simu.clusters),
               fowlkes.mallows = fowlkes_mallows(rhierbaps.results[[clust]], temp.simulation$simu.clusters)))
    
  }))
  
  temp.results.df <- rbind(fastbaps.results.df,
                           snapclust.results.df,
                           rhierbaps.results.df)
  temp.results.df<- cbind(do.call(rbind, rep(list(params), nrow(temp.results.df))),
                          temp.results.df)
  
  return(temp.results.df)
  
},  mc.cores = CPU))

write.table(results.df, file="./simulations/simulation_results_island_no_structure.csv",
            row.names = FALSE, col.names = TRUE, quote=FALSE, sep=",")
```

plot some results

recombination high (rate=10)

```{r}
ggplot(results.and.params.df[results.and.params.df$recombination.rate==10,], aes(x=method, y=value, col=method)) + geom_point() +
  facet_grid(n.pop ~ migration.rate) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))
```

recombination medium (1)

```{r}
ggplot(results.and.params.df[results.and.params.df$recombination.rate==1,], aes(x=method, y=value, col=method)) + geom_point() +
  facet_grid(n.pop ~ migration.rate) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))
```

recombination low (0)

```{r}
ggplot(results.and.params.df[results.and.params.df$recombination.rate==0,], aes(x=method, y=value, col=method)) + geom_point() +
  facet_grid(n.pop ~ migration.rate) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))
```